struct Edge {
    int to, capi, id;
};
struct Graph {
    const int inf = 1e9;
    vector<vector<Edge>> g;
    vector <int> dep, cur;
    int S, T;
    Graph(){}
    Graph(int n): g(n+1), dep(n+1), cur(n+1) {}
    void set(int s, int t){
        S = s, T = t;
    }
    void clear(){
        for (auto &j : g) j.clear();
    }
    void add(int a, int b, int c){
        int ra = g[a].size(), rb = g[b].size();
        g[a].push_back({b, c, rb});
        g[b].push_back({a, 0, ra});
    }
    bool bfs(){
        fill(dep.begin(), dep.end(), -1);
        queue <int> Q;
        Q.push(S), dep[S] = 0;
        while (!Q.empty()){
            auto u = Q.front();
            Q.pop();
            for (auto &j : g[u]){
                if (dep[j.to] == -1 && j.capi){
                    dep[j.to] = dep[u] + 1;
                    Q.push(j.to);
                }
            }
        }
        return dep[T] != -1;
    }
    int dfs(int u, int limi){
        if (u == T) return limi;
        for (int i = 0; i < g[u].size(); ++ i){
            cur[u] = i;
            auto &j = g[u][i];
            if (dep[j.to] == dep[u]+1 && j.capi){
                int cut = dfs(j.to, min(limi, j.capi));
                if (cut > 0){
                    j.capi -= cut;
                    g[j.to][j.id].capi += cut;
                    return cut;
                } else {
                    dep[j.to] = -1;
                }
            }
        }
        return 0;
    }
    int dinic(){
        int res = 0, flow = 0;
        while (bfs()){
            fill(cur.begin(), cur.end(), 0);
            while (flow = dfs(S, inf)){
                res += flow;
            }
        }
        return res;
    }
};