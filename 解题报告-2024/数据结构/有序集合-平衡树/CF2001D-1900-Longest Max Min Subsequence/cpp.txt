#include <bits/stdc++.h>
using namespace std;

void solve(){
    int n;
    cin >> n;
    vector <int> nums(n), Rp(n,-1), dele(n);
    vector <vector<int>> Ps(n);
    for (auto &x : nums) cin >> x, -- x;

    set <int> alls;
    for (int i = 0; i < n; ++ i){
        Rp[nums[i]] = i;
        Ps[nums[i]].push_back(i);
    }
    for (int i = 0; i < n; ++ i){
        if (Rp[i] != -1){
            alls.insert(Rp[i]);
        }
    }

    vector <int> ans;
    int f = 0, lt = -1, rt = -1;
    multiset <int> mst;
    while (!alls.empty()){
        // 从 所有元素 最右端 的位置  最左边的一个元素开始处理， 这样可以保证 不重不漏 是最长的
        int R = *alls.begin();
        while (rt < R){
            if (!dele[nums[++rt]]){
                mst.insert(nums[rt]);
            }
        }
        int num = f ? *mst.begin() : *mst.rbegin();
        f = !f;
        alls.erase(Rp[num]);  
        dele[num] = 1, ans.push_back(num);
/*
   因为该元素 被选， 在后面无需处理，并且删去 左边无用 的 元素， lt前已经被选， 所以查找该元素 大于等于 lt+1 后面出现的位置
*/

        int pos = *lower_bound(Ps[num].begin(), Ps[num].end(), lt+1);
        while (lt+1 <= pos){
            ++ lt;
            mst.extract(nums[lt]);
        }
        mst.erase(num);
    }

    cout << ans.size() << "\n";
    for (int i = 0; i < ans.size(); ++ i) cout << ans[i]+1 << "\n "[i < ans.size()-1];
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int _ = 1;
    cin >> _;
    while (_ --)
        solve();
    return 0;
}