#include <bits/stdc++.h>
using namespace std;
using Pii = pair<int,int>;
using ll = long long;
const int N = 1001, mod = 1e9 + 7, inf = 1e9;
/*
    f[u][j]表示在对u操作之前，u的所有子树都有含有 w[u]的 第j小因子的最小步数
    O(n*divsor(max{a_i})*divsor(max{a_i}))
*/
vector<int> divs[N];
void solve(){
    int n, k;
    cin >> n >> k;
    vector<vector<int>> g(n+1), f(n+1);
    vector<int> w(n+1);
    for (int i = 1; i <= n; ++ i){
        cin >> w[i];
        f[i].resize(divs[w[i]].size());
    }
    for (int i = 0; i < n-1; ++ i){
        int a, b;
        cin >> a >> b;
        g[a].push_back(b), g[b].push_back(a);
    }

    function<void(int,int)> dfs = [&](int u, int fa){
        for (auto &x : g[u]){
            if (x == fa) continue;
            dfs(x, u);
            for (int i = 0; i < divs[w[u]].size(); ++ i){
                int mins = k+1;
                for (int j = 0; j < divs[w[x]].size(); ++ j){
                    int a = divs[w[u]][i], b = divs[w[x]][j];
                    if (b%a == 0) mins = min(mins, f[x][j]);
                    else if ((b*b)%a == 0) mins = min(mins, f[x][j]+1);
                }
                f[u][i] += mins;
            }
        }
        f[u][0] = 0;
    };
    dfs(1, -1);

    int res = w[1];
    for (int i = divs[w[1]].size()-1; i >= 0; -- i){
        if (f[1][i]+1 <= k){
            res *= divs[w[1]][i];
            break;
        }
    }
    cout << res << "\n";
}

int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int _ = 1;
    for (int i = 1; i < N; ++ i)
        for (int j = i; j < N; j += i)
            divs[j].push_back(i);
    cin >> _;
    while (_--)
        solve();
    return 0;
}
