给定两个序列 𝑎, 𝑏将 b 中所有元素以任意顺序在任意位置插入 𝑎 中，使得形成的新序列 c 的最长上升子序列最短，输出你的序列 c

#include <bits/stdc++.h>
using namespace std;
using Pii = pair<int,int>;
using ll = long long;
const int N = 4e5+10, mod = 1e9 + 7, inf = 1e9;
/*
	只需要在遍历A的a[i]时候，将B中比A大的全部b[j]插到A之前，这样可以保证以A[i]为首的任何一个上升子序列，长度都不会增加。
*/
void solve(){
    int n, m;
    cin >> n >> m;
    vector <int> A(n+1), B(m+1), C;
    for (int i = 1; i <= n; ++ i) cin >> A[i];
    for (int i = 1; i <= m; ++ i) cin >> B[i];
    sort(B.begin()+1, B.end(), greater<int>());
    

    for (int i = 1, j = 1; i <= n; ++ i){
        while (j <= m && A[i] <= B[j]) C.push_back(B[j]), ++ j;
        C.push_back(A[i]);
        if (i == n && j <= m){
            while (j <= m) C.push_back(B[j]), ++ j;
        }
    }

    for (auto &x : C) cout << x << " ";
    cout << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    cin >> _;
    while (_--)
        solve();
    return 0;
}
