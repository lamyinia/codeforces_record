#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using f64 = long double;
using u64 = unsigned long long;
const f64 eps = 1e-12;
const i64 inf_i64 = 1e18;
const int inf_int = 1e9;
template <class T> void fmax(T &a, const T &b){
    if (b > a) a = b;
}
template <class T> void fmin(T &a, const T &b){
    if (b < a) a = b;
}
template <class T> void print(vector <T> &A, int d = 0){
    int n = A.size();
    for (int i = 0; i < n; ++ i){
        if (i) cout << " ";
        cout << A[i]+d;
    }
    cout << "\n";
}
int jgs(f64 x){
    return x < -eps ? -1 : x > eps;
}

void solve(){
    auto __lcm = [&](i64 x, i64 y)->i64{
        return x*y / __gcd(x, y);
    };

    int n, m;
    cin >> n >> m;
    vector<vector<int>> gra(n), chuks, chuks_edge;
    vector <i64> lcms, gcds;
    vector<array<int,2>> uvs;
    vector <int> vis(n, -1), ans(n);

    bool jug = 1;
    for (int i = 0,u,v,g,l; i < m; ++ i){
        cin >> u >> v >> g >> l;
        u -= 1, v -= 1;
        gra[u].push_back(i);
        gra[v].push_back(i);

        gcds.push_back(g);
        lcms.push_back(l);
        uvs.push_back({u, v});
        if (l%g) jug = 0;
    }
    if (!jug){
        cout << "NO\n";
        return;
    }

    auto dfs_divide = [&](auto &&self, int u, int color, vector<int>&chuk)->void{
        vis[u] = color;
        chuk.push_back(u);
        for (auto &id : gra[u]){
            int v = uvs[id][0]+uvs[id][1] - u;
            if (vis[v] != -1) continue;
            self(self, v, color, chuk);
        }
    };
    for (int i = 0, color = 0; i < n; ++ i){
        if (vis[i] == -1){
            vector <int> chuk;
            dfs_divide(dfs_divide, i, color ++, chuk);
            chuks.push_back(chuk);
        }
    }

    const int tot = chuks.size();
    chuks_edge.resize(tot);
    for (int i = 0; i < m; ++ i){
        auto [u, v] = uvs[i];
        assert(vis[u] == vis[v]);
        chuks_edge[vis[u]].push_back(i);
    }

    auto dfs_chk = [&](auto &&self, int u, bool &jug)->void{
        if (ans[u] > (int)1e6){
            jug = 0;
        }

        if (!jug) return;  // jug判断 ans的范围
        for (auto &id : gra[u]){
            int v = uvs[id][0]+uvs[id][1] - u;

            if (ans[v] != 0) continue;
            if (lcms[id]%ans[u] || ans[u]%gcds[id]){
                jug = 0;
                return;
            }

            ans[v] = lcms[id] * gcds[id] / ans[u];
            self(self, v, jug);
            if (!jug) return;
        }
    };
    auto chk = [&](int u, int val)->bool{
        for (auto &id : chuks[vis[u]]){
            ans[id] = 0;
        }

        ans[u] = val;
        bool jug = 1;
        dfs_chk(dfs_chk, u, jug);
        if (!jug) return false;

        for (auto &id : chuks_edge[vis[u]]){
            auto [u, v] = uvs[id];
            i64 g = gcds[id], l = lcms[id];
            if (__gcd(ans[u], ans[v]) != g || __lcm(ans[u], ans[v]) != l){
                return false;
            }
        }

        return true;
    };

    for (int i = 0; i < tot; ++ i){
        if (chuks[i].size()==1){
            ans[chuks[i][0]] = 1;
            continue;
        }

        int id = chuks_edge[i][0];
        int u = uvs[id][0], l = lcms[id], g = gcds[id];
        bool jug = 0;
        for (int i = 1; i*i <= l; ++ i){  // 枚举因子
            if (l%i == 0){
                int x = i, y = l/i;
                if (x%g == 0){
                    if (chk(u, x)){
                        jug = 1;
                        break;
                    }
                }
                if (x != y && y%g == 0){
                    if (chk(u, y)){
                        jug = 1;
                        break;
                    }
                }
            }
        }
        if (!jug){
            cout << "NO\n";
            return;
        }
    }

    cout << "YES\n";
    print(ans);
}


int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--){
        solve();
    }
    return 0;
}