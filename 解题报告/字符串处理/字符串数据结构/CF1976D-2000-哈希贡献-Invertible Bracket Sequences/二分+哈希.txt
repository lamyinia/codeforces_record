#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5+5, inf = 1e9;
 
int f[N][20], lg2[N];
int Pre[N];

void solve(){   
    string s;
    cin >> s;
    int n = s.size();
    s = " " + s;
    map <int, vector<int>> mp;
 
    for (int i = 1; i <= n; ++ i){
        Pre[i] = Pre[i-1] + (s[i]=='(' ? 1 : -1);
        mp[Pre[i]].push_back(i);
    }

    for (int j = 0; 1<<j <= n; ++ j){
        for (int i = 1; i+(1<<j)-1 <= n; ++ i){
            if (!j) f[i][j] = Pre[i];
            else f[i][j] = max(f[i][j-1], f[i+(1<<j-1)][j-1]);
        }
    }
    
    function<int(int, int)> query = [&](int l, int r){
        int t = lg2[r-l+1];
        return max(f[l][t], f[r-(1<<t)+1][t]);
    };
 
    ll res = 0;
    for (int i = 1; i <= n; ++ i){
        //二分最远的合法右端点
        int l = i, r = n;
        while (l < r){
            int mid = l+r+1 >> 1;
            if (query(i, mid) <= Pre[i-1]*2) l = mid;
            else r = mid-1;
        }
        //如果合法
        if (query(i, l) <= Pre[i-1]*2){
            vector<int> &it = mp[Pre[i-1]];
            int lp = lower_bound(it.begin(), it.end(), i) - it.begin();
            int rp = upper_bound(it.begin(), it.end(), l) - it.begin() - 1;
            if (lp <= rp) res += rp-lp+1;
        }
    }
    cout << res << "\n";
}
 
signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int _ = 1;
    cin >> _;
    for (int i = 1; i < N; ++ i)
        lg2[i] = __lg(i);
    while (_--) solve();
    return 0;
}