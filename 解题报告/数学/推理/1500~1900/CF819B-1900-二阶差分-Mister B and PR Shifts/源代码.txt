#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2005000, inf = 0x3f3f3f3f, P = 998244353;

/*
	每个数字对结果数组的贡献 是一个 一次函数，我们可以用差分来维护这些分段的 一次函数
	在算贡献的时候 我们可以只算一半，因为原数是正数的 部分和 等于 原数是 负数 的 部分和
*/
ll f[N];
void solve(){
    int n;
    cin >> n;
    vector <ll> a(n+1), dif1(2*n+1), dif2(2*n+1);
    for (int i = 1; i <= n; ++ i) cin >> a[i];

    for (int i = 1; i <= n; ++ i){
        int l = n+a[i]-i, r = 2*n-i;
        ++ dif1[l], -- dif1[r+1];
        dif2[l] -= l, dif2[r+1] += l;
    }
    for (int i = 0; i < 2*n; ++ i)
        dif1[i+1] += dif1[i], dif2[i+1] += dif2[i];

    for (int i = 0; i < 2*n; ++ i)
        f[i%n] += 1ll*dif1[i]*i + dif2[i];

    ll res = 0, cost = 2e18;
    for (int i = 0; i < n; ++ i)
        if (cost > f[i])
            cost = f[i], res = i;
    
    cout << 2*cost << " " << res << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--) solve();
    return 0;
}

/*
二维差分写法
import sys

input = lambda: sys.stdin.readline().rstrip()
sys.stdin = open('../input.txt', 'r')
I = lambda: int(input())
MI = lambda: map(int, input().split())
GMI = lambda: map(lambda x: int(x) - 1, input().split())
LGMI = lambda: list(GMI())


tcn = 1
for _tcn_ in range(tcn):
    n = I()
    A = LGMI()

    d2 = [0] * (2 * n + 1)
    d = [0] * (2 * n + 1)
    f = [0] * (2 * n + 1)

    for i, a in enumerate(A):

        L1, R1 = n - 1 - i, n - 1 - i + a
        L2, R2 = R1 + 1, L1 + n - 1
        f[L1] += R1 - L1 + 1
        d2[L1] -= 1
        d2[R1 + 1] += 1
        d2[L2] += 1
        d2[R2 + 1] -= 1
        f[R2 + 1] -= R2 - L2 + 1

    for i in range(n * 2):
        if i > 0:
            d[i] += d[i - 1] + d2[i]
        else:
            d[i] = d2[i]

    for i in range(n * 2):
        if i > 0:
            f[i] += f[i - 1] + d[i]
        else:
            f[i] += d[i]

    ans = [0] * n
    ans[0] = f[n - 1]
    for i in range(n - 1):
        ans[i + 1] = f[n + i] + f[i]

    print(min(ans), ans.index(min(ans)))
*/