#include <bits/stdc++.h>
using namespace std;
using Pii = pair<int,int>;
using ll = long long;
const int N = 4e5+10, mod = 1e9 + 7, inf = 1e9;
/*
    给定一个序列，求数对[l,r]的个数，使元素大小在[l,r]范围内的值删去后，数组非严格递增
    核心思路：删除元素后，对于剩余的每个元素，考虑其出现位置的区间，这些区间必须不相交
            这样将一个不连续的问题转化为了连续的问题
    于是分别讨论删除某个前缀和后缀的情况，
*/
struct Info {
    int l, r, v;
};

void solve(){
    vector <Info> P(1e6+1);
    for (int i = 1; i <= 1e6; ++ i){
        P[i].l = 1e9, P[i].v = i;
    }
    int n, x;
    cin >> n >> x;

    for (int i = 1, x; i <= n; ++ i){
        cin >> x;
        if (P[x].l == 1e9) P[x].l = i;
        P[x].r = i;
    }
    vector <Info> B;
    for (auto &it : P){
        if (it.r > 0) B.push_back(it);
    }

    n = B.size()-1;
    int i = 0;
    while (i < n && B[i].r < B[i+1].l) ++ i;
    if (i == n){
        cout << 1ll*x*(x+1)/2 << "\n";
        return;
    }
    ll res = 1ll*B[i+1].v*(x-B[n].v+1);
    for (int j = n; j==n||B[j].r < B[j+1].l; -- j){
        while (i >= 0 && B[i].r >= B[j].l) -- i;
        res += 1ll*B[i+1].v*(B[j].v-B[j-1].v);
    } 

    cout << res << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--)
        solve();
    return 0;
}