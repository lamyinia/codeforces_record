#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 300500, inf = 1e9;

void solve(){
    int n, m, res = 1;
    cin >> n >> m;
    vector <int> bok[n+1];
    vector<vector<int>> g(n+1);
    for (int i = 1; i <= n; ++ i){
        int s, x;
        cin >> s;
        if (res < s) res = s;
        while (s--){
            cin >> x;
            bok[i].push_back(x);
        }
    }

    for (int i = 1; i < n; ++ i){
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
        // 含有相同的冰淇淋是一个连通子图
    }
    map <int,int> mp;
    vector <int> ans(m+1);
    /*
        对于之前染过色的冰淇淋，先给他染上同种颜色，对于剩下的冰淇淋，
        依次选取当前最小的且当前顶点中没用过的颜色
        它已经给出了树上的依赖关系，关系一定满足限制条件，按照这个树遍历即可

        dfs序同时有连通性的性质，为了新图的顶点互不影响
    */
    function<void(int,int)> dfs = [&](int u, int fa){
        mp.clear();
        for (auto &x : bok[u]){
            if (ans[x] != 0) mp[ans[x]] = 1;
        }
        int cnt = 0;
        for (auto &x : bok[u]){
            if (ans[x]) continue;
            while (mp[++ cnt]);
            ans[x] = cnt;
        }
        for (auto &x : g[u])
            if (x != fa)
                dfs(x, u);
    };

    dfs(1,-1);
    cout << res << "\n";
    for (int i = 1; i <= m; ++ i){
        cout << (ans[i] ? ans[i] : 1) << "\n "[i < m];
    }
} 
 
int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--) solve();
    return 0;
}