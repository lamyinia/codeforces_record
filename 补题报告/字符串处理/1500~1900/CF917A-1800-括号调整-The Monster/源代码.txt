/*
给定一个由"?"、"("、")"三种字符组成的字符串 s，长度为n(2 <n< 5000)，问有多少个合法的子串。个字符串合法是说，把其中的"?替换成"("或")"，能够使得每一个左括号都找到唯一与之对应的右括号
*/

#include <bits/stdc++.h>
using ll = long long;
using namespace std;

void solve(){

    string s;
    cin >> s;

    int n = s.size();
    ll res = 0;
    for (int i = 0; i < n; ++ i){
        int cnt = 0, cntb = 0;
        for (int j = i; j < n; ++ j){
            if (s[j] == '(') ++ cntb;
            else if (s[j] == ')') -- cntb;
            else -- cntb, ++ cnt;
            if (cntb < 0){
                if (cnt <= 0) break;
                -- cnt, cntb += 2;
            }
            if (!cntb) ++ res;
        }
    }

    cout << res << "\n";
}

int main(){
    int _ = 1;
    while (_--) solve();
    return 0;
}
/*
从头遍历到尾，每次遇到前括号就+1，否则-1，要求最后结果为0，且中间不经过负数，我们称之为一个前缀和。

我们可以从头到尾进行遍历，如果遇到问好先设定为右括号，如果遇到的前缀和小于0，再把前面还没换成左括号的右括号换成左括号，这么做可以保证我们中间经历的所有数的是非负的，同时最后的前缀和最小。

一个子字符串添加其右侧的字符会得到一个新的子字符串，我们维护当前能到达的最小值以及可以转化的右括号数量。

我们这里只需要说明新增字符的时候，这两个数字如何改变。如果我们遇到问号，先强行赋为右括号，接下来如果使得前缀和为负数，则尝试找到之前问号变成的右括号将其变成左括号，使得当前可达的最小值+2不再为负数。之所以增加的数值是2，是因为相当于从-1变成了1。
*/
