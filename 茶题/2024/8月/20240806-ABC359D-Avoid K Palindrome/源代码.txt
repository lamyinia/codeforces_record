#include <bits/stdc++.h>
using namespace std;
using Pii = pair<int,int>;
using ll = long long;
const int N = 1050, M = 1<<10, mod = 998244353, inf = 1e9;
int f[N][M], illegal[M];
/*
    状态压缩dp：
        f[i][j] 表示前i个字符，且最后k个字符的状态是j的方案数
        考虑处理前导零:
            在 i < k 一定能够从前面转移过来，此时f[i][j]表示最后i个字符的状态是j的方案数
                f[i][j] = sigma{f[i-1][j] | 0 <= j <= 1<<(i-1)-1}
        否则：
            f[i][j] = sigma{f[i-1][j] |  j is not a legal palindrome}
*/
void solve(){
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    s = " " + s;
    auto check = [&](int x)->bool{
        for (int i = 0; i < k/2; ++ i){
            if ((x>>i&1) != (x>>k-i-1 & 1)) return false;
        }
        return true;
    };

    f[1][0] = k > 1 && (s[1]=='A' || s[1]=='?');
    f[1][1] = k > 1 && (s[1]=='B' || s[1]=='?');

    int up = (1<<k)-1;
    for (int i = 1; i < n; ++ i){
        for (int u = 0; u <= up; ++ u){
            if (!f[i][u]) continue;
            for (int p = 0; p <= 1; ++ p){
                if (s[i+1]=='?' || s[i+1]-'A'==p){
                    if (i+1 < k) (f[i+1][((u<<1)&up)|p] += f[i][u]) %= mod;
                    else {
                        int to = ((u<<1)&up)|p;
                        if (!check(to))
                            (f[i+1][to] += f[i][u]) %= mod;
                    }
                }
            }
        }
    }
    
    int res = 0;

    for (int i = 0; i <= up; ++ i){
        res += f[n][i];
        res %= mod;
    }

    cout << res << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--)
        solve();
    return 0;
}