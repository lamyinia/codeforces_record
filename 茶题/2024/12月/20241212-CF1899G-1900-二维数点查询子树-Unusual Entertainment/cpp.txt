#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
template <class T> void fmax(T &a, const T &b){
    if (b > a) a = b;
}
template <class T> void fmin(T &a, const T &b){
    if (b < a) a = b;
}
template <class T> struct fenwick {
    vector <T> info;
    int n;
    fenwick(){}
    fenwick(int n): info(n+1), n(n){}
    void init(int n){
        info.resize(n+1), this->n = n;
        for (int i = 0; i <= n; ++ i) info[i] = 0;
    }
    void update(int x, T c){
        while (x <= n) info[x] += c, x += x&-x;
    }
    T query(int x) {
        T res = 0;
        while (x) res += info[x], x -= x & -x;
        return res;
    }
    int select(int kth){  // 找到 小于kth的 最后一个下标
        T ans = 0, cnt = 0;
        for (int i = 20; i >= 0; -- i){
            ans += 1 << i;
            if (ans >= n || cnt + info[ans] >= kth) ans -= 1 << i;
            else cnt += info[ans];
        }
        return ans+1;  // +1 就是第kth小数字
    }
};

void solve(){
    using Yint = fenwick<int>;

    int n, q;
    cin >> n >> q;
    vector<vector<int>> g(n);
    vector <int> seqs(n+1), Lord(n), Rord(n);
    for (int i = 0,x,y; i < n-1; ++ i){
        cin >> x >> y;
        x -= 1, y -= 1;
        g[x].push_back(y);
        g[y].push_back(x);
    }

    for (int i = 1; i <= n; ++ i){
        cin >> seqs[i];
        seqs[i] -= 1;
    }

    int tot = 0;
    auto dfs = [&](auto &&self, int u, int presor)->void{
        Lord[u] = ++ tot;
        for (auto &v : g[u]){
            if (v == presor) continue;
            self(self, v, u);
        }
        Rord[u] = tot;
    };
    dfs(dfs, 0, -1);
    assert(tot == n);

    vector <int> ans(q), opts(q);
    vector<vector<int>> Ls(n+1), Rs(n+1);  // 存储树状数组要查询前缀和的编号

    for (int i = 0; i < q; ++ i){
        int l, r, x;
        cin >> l >> r >> x;
        x -= 1;
        Ls[l-1].push_back(i);
        Rs[r].push_back(i);
        opts[i] = x;
    }

    Yint Y(n);

    for (int i = 1; i <= n; ++ i){
        int x = seqs[i];
        Y.update(Lord[x], 1);
        for (auto &id : Rs[i]){
            int &u = opts[id];
            int &lo = Lord[u], &hi = Rord[u];
            ans[id] += Y.query(hi) - Y.query(lo-1);   
        }
        for (auto &id : Ls[i]){
            int &u = opts[id];
            int &lo = Lord[u], &hi = Rord[u];
            ans[id] -= Y.query(hi) - Y.query(lo-1);   
        }
    }
    // return;
    for (auto &x : ans){
        cout << (x > 0 ? "YES\n" : "NO\n");
    }
    cout << "\n";
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    cin >> _;
    while (_--) solve();
    return 0;
}