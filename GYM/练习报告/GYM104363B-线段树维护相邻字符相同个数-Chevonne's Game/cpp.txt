#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using f64 = long double;
using u64 = unsigned long long;
const f64 eps = 1e-12;
const i64 inf_i64 = 1e18;
const int inf_int = 1e9;
template <class T> void fmax(T &a, const T &b){
    if (b > a) a = b;
}
template <class T> void fmin(T &a, const T &b){
    if (b < a) a = b;
}
template <class T> void print(vector <T> &A, int d = 0){
    int n = A.size();
    for (int i = 0; i < n; ++ i){
        if (i) cout << " ";
        cout << A[i]+d;
    }
    cout << "\n";
}
int jgs(f64 x){
    return x < -eps ? -1 : x > eps;
}
template <class T> struct SegmentTree{
    struct Node {
        T v0, v1, bitL, bitR, lazy;
    };
    const Node Null = {0, 0, -1, -1, 0};
    vector <Node> info;
    int n, cnt;

    SegmentTree(int n): info(4*n+10), n(n){}
    Node merge(Node u1, Node u2){
        if (u1.bitL == -1) return u2;
        if (u2.bitL == -1) return u1;

        Node u = {u1.v0+u2.v0, u1.v1+u2.v1, u1.bitL, u2.bitR, 0};
        if (u1.bitR == u2.bitL){
            int both = u1.bitR;
            if (both == 0) u.v0 += 1;
            else u.v1 += 1;
        }
        return u;
    }
    void apply(int u){
        info[u].lazy ^= 1;
        swap(info[u].v0, info[u].v1);
        info[u].bitL ^= 1, info[u].bitR ^= 1;
    }
    void push(int u){
        assert(info[u].lazy);
        apply(u*2), apply(u*2+1);
        info[u].lazy = 0;
    }
    void pull(int u){
        info[u] = merge(info[u*2], info[u*2+1]);
    }
    void init(int u, string &s, int lt, int rt){
        if (lt == rt){
            int c = s[lt]-'0';
            info[u] = {0, 0, c, c, 0};
            return;
        }
        
        int mid = (lt+rt) >> 1;
        init(u*2, s, lt, mid);
        init(u*2+1, s, mid+1, rt);
        pull(u);
    }
    void init(string &s){
        cnt = 0;
        init(1, s, 0, n-1);
    }
    void update(int u, int l, int r, int lt, int rt){
        if (rt < l || lt > r) return;
        if (lt >= l && rt <= r){
            apply(u);
            return;
        }

        assert(++ cnt <= 100);

        if (info[u].lazy) push(u);
        int mid = (lt+rt) >> 1;
        update(u*2, l, r, lt, mid);
        update(u*2+1, l, r, mid+1, rt);
        pull(u);
    }
    void update(int l, int r){
        cnt = 0;
        update(1, l, r, 0, n-1);
    }
    Node query(int u, int l, int r, int lt, int rt){
        if (rt < l || lt > r) return Null;
        if (lt >= l && rt <= r){
            return info[u];
        }

        assert(++ cnt <= 100);

        if (info[u].lazy) push(u);
        int mid = (lt+rt) >> 1;
        Node ret = Null;
        ret = merge(ret, query(u*2, l, r, lt, mid));
        ret = merge(ret, query(u*2+1, l, r, mid+1, rt));
        return ret;
    }
    Node query(int l, int r){
        cnt = 0;
        return query(1, l, r, 0, n-1);
    }
};
using Yint = SegmentTree<int>;

void solve(){
    int n, q;
    cin >> n >> q;
    string s;
    cin >> s;
    Yint Y(n);
    Y.init(s);

    while (q--){
        char opt;
        int l, r;
        cin >> opt >> l >> r;
        l -= 1, r -= 1;
        if (opt == 'Q'){
            auto U = Y.query(l, r);
            cout << max(U.v0, U.v1) + 1 << "\n";
        } else {
            Y.update(l, r);
        }
    }
}

int main(){
#ifdef ONLINE_JUDGE
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
#else
    freopen("in.txt", "rt", stdin), freopen("out.txt", "wt", stdout);
#endif
    int _ = 1;
    while (_--){
        solve();
    }
    return 0;
}